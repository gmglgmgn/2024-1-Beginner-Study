# 배운 것

#### 형상관리의 필요성
1. 언제까지
	- 최종
	- 최최종
	- 최최최최최종
	- 찐최종
	- 찐찐최종
	반복할래?
	코드의 크기가 커질수록 이렇게 주먹구구식으로 관리하기 어려워진다.
	왜? 작은 서비스만 하더라도 수많은 코드 파일이 존재할 수 있다. 그게 다 저렇게 관리되고 있다면...
2. 협업 할 때 발생할 수 있는 문제
	- 코드에서 문제 발생! 누가 짰어?
	- 각 코드들을 메일로 공유한다? USB로 공유한다? USB는 번거롭고 공간에 제약이 크고, 메일로 공유한다면 스팸이 될 수 있겠지.. 작성자가 다른 사람들에게 푸시하기보다 깃에 코드를 보관하고, 필요한 사람들이 풀링하는 것이 더 간편하겠다.
1. 버전 관리의 중요성
	- 코드 작성 후 배포한 상태에서
	- 헉~ 문제 발생!! 이전 코드가 어딨더라...? 복구에 한 세월...
	- 깃 에서 제공하는 옵션을 사용하면 몇 분만에 장애 복구 가능!

#### 깃이 추적하는 것
1. 어떤 파일이 수정되었는지
2. 누가 수정했는지
3. 언제 수정됐는지
4. 어떻게 수정됐는지

VS Code bash 터미널에서 git log 입력 시 보여주는 정보들인 듯!


#### 깃에서 관리되는 파일의 생명주기
1. 언트랙트 - 트래킹 되지 않는 상태.
	로컬에서 git add 를 하지 않고 수정 중인, 혹은 생성한 파일을 이야기 하는 듯.	
1. 트랙트 - 관리되고 있는 상태.
	1. 언모디파이드
		아직 손대지 않은 상태. git add 후 겠지?
	2. 모디파이드
		변경 중인 파일.
	3. 스테이지드
		이게 git add 후 인가?
		이 상태에서 commit 을 하면, unmodified 상태로 간다네?
		*이건 로컬 레포지토리에 있는 파일이 변경된다는 소리겠지?*
		*그렇다면 커밋을 하지 않는다면, .git 이 있는 로컬 폴더에서 파일에 무슨 변형을 가하더라도 편집기를 종료하고 다시 파일을 불러오면 commit 되어 있는 그 버전으로 돌아가 있는 걸까?*


#### 깃의 큰 그림
3가지 영역으로 나눠짐.
1. 워킹 디렉토리
	1. .git 이 위치한 현재 작업중 폴더를 의미하는 것 같다.
2. 스테이징 에어리어
	1. git add 이후의 파일들이 위치하는 공간.
	2. *트랙트가 되고 있을텐데, 어떤식으로 되고 있을까?
3. 로컬 레포지토리
	1. 로컬에 위치하는 저장소. 
	2. git commit 이 적용된 파일들이 존재한다.
4. 리모트 레포지토리
	1. 협업을 위한 깃 허브에 위치한 레포지토리.
	2. 로컬에서 작업 후 git push 한 파일들이 존재한다.

여기까지는 대충 이해했는데,
*fetch, merge, pull, clone, checkout 명령은 어떤 동작을 하는걸까?*
*merge와 pull 이 동일한 색상을 가진 걸 보니 비슷한 동작을 하는걸까?*
*checkout과 clone 도?* 
*fetch는 무슨 용도일까? 이름만 봐서는 fetch와 clone의 차이를 모르겠는데..*
*다음주에 배우겠지?*


#### 오늘 배운 명령어
1. git init
	현재 pwd에 .git 숨겨진 폴더를 만들어, git으로 형상관리를 시작함.
2. rm -r .git
	git으로 관리하기 싫어~
	*리눅스에서 -r이 뭐였더라 디렉터리 삭제할 때 쓰는 옵션이었나?
3. git add 인자(파일명, or 경로)
	파일을 스테이지드 상태로 돌린다. 
	*.git이 없는 폴더의 경로를 입력하면 어떻게 될까?
1. git rm --cached 인자(파일명)
	파일을 언 스테이지드 상태로 돌리자.
5. git commit -m 인자(타입:서브젝트)
	1. 커밋 메시지는 의미가 명확하게!
	2. 파일 수정 후 로컬 레파지토리에 옮기는 명령.
6. git config --global user.name 인자(깃허브이름)
7. git config --global user.email 인자(가입 이메일)
	아하 마지막의 두 코드는 커밋 시 누가 커밋했는지 기본값을 적용하는 코드라고 한다!


#### 커밋 메시지 가이드라인
타입:서브젝트 형식으로 작성하자.
왜? 제대로 작성되지 않은 커밋 메시지는 해당 커밋이 어떤 활동을 위해서 이루어진 것인지 읽는 이를 난해하게 한다.

###### 타입
- 이 커밋이 어떤 카테고리의 작업을 한 것인지 명시.
- feat - 새로운 기능 추가
- refactor - 기존 코드의 개선
- fix - 버그 수정
- chore - 코드 외 설정의 변경 시
- docs - 문서화
- test - 테스트 코드 - 테스트 시나리오 대로 작성한 코드인가?

###### 서브젝트
- 어떤 작업을 한 건지 어떤 변화를 줬는지?
- 버그 픽스인 경우, 어떤 버그를 픽스했는지..

#### 깃과 깃허브 연동하기
git remote add origin 저장소URL
git branch -M main
git push -u origin main
3가지 명령을 사용하면 된다.

첫번째는 인자로 주어진 URL을 리모트 레포지토리로 추가한다는 의미 같은데,
*두번째의 branch -M main 명령은 무슨 뜻일까? 메인 브랜치라는 말이 있던데, -M 옵션을 이용해서 main 을 메인 브랜치로 설정한다는 뜻 일까? 깃 설치 시 .git 위치한 곳을 main 이라는 alias 로 부르게 설정했던 것 같은데..*
*세번째는 무슨 뜻일까? 일단 push는 원격 저장소에 뭔가 올리거나 변경 사항을 올리는 명령이었으니.. 흠 모르겠다...* 
*그리고 왜 폴더를 내 유저이름과 같게 설정하라고 했을까?*

#### 오너 이름과 같은 레포지토리
*특수한 레포지토리 라는데, README.md 가 자동으로 추가된다고... 사실 뭐가 특별한지 모르겠다... 내 소개용으로 사용하는 레포지토리라고 생각해도 되나?*

#### 기타 실수 및 알게된 점
1. 저장하지 않으면 빈 파일 올라간다! 이것 때문에 커밋 다시했다 ㅋㅋㅋ
2. 원격 레포지토리에 올리기 위해서는 3단계의 메시지를 모두 작성해야 하는 것 같다. git add 를 빼먹으니 제대로 커밋도 되지 않고 올라가지도 않더라.
3. git push origin mai 안하고 git push 만 해도 파일의 바뀐 상태가 원격 레포지토리에 적용되던데 둘이 무슨 차이일까?
# 느낀점
처음이라 그런지 우왕좌왕 한 것도 많았지만, 처음으로 커밋 해보니 뭔가 개발자의 세계로 한 발 내딛은 것 같아 뿌듯했다. 
혼자서는 우주선 계기판 같이 보였던 깃 허브 메인 페이지에 내가 아는 버튼 몇 개가 생겼더니 좀 친근해진 기분이고 덜 무서워 보이더라 ㅋㅋㅋ
이것저것 좀 궁금한 것들이 생겼는데, 아마 다음주부터 좀더 자세하게 알 수 있게 되지 않을까 싶다. 질문하기 전에 검색도 해보고 좀 해봐야지. 
그리고 수업 들으면서 메모한다고 자꾸 강의 내용을 놓치고 그랬는데, 다음주에는 아무래도 듣는 것에만 집중해야겠다. 

# 개인 레포지토리 주소
<https://github.com/gmglgmgn/gmglgmgn>